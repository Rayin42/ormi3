<!DOCTYPE html>
<html lang="ko-KR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //메소드 -> 객체 안의 함수!! console.log()  <<- log가 메소드

        //const x = ?
        // 2 보다 크거나 또는 7보다 작은 x 값 => t/f
        //x>2 || x<7

        // 2 보다 크지 않거나 또는 7보다 작은 x 값 => t/f
        //!(x>2) || x<7

        //function
        //함수는 실행을 하면 일련의 과정을 거치고 결과값을 돌려준다.
        //함수는 1. 재사용성이 높아진다 2. 유지보수가 용이하다 3. 구조 파악이 용이하다 /는 이유로 사용됨
        // function test(a, b, c){
        //     return a + b + c
        // }
        // console.log(test(1, 2));

        // <화살표 함수(익명함수, 람다식)>------------------------
        // function 함수1(x, y) {
        //   return x + y
        //}
        // let 함수1 = (x, y) => x + y;
        // let 함수2 = x => x + 10; 인자가 1개면 이렇게도 가능
        // 


        // <즉시실행함수>----------------------------------
        // (x, y) => x + y;
        // ((x,y) => x+y)(1, 2)의 형태


        // let arr1 = [1, 2, 3];
        // let arr2 = arr1;
        // console.log(arr2);

        //arr1[0] = 10;
        //console.log(arr1);
        //console.log(arr2);
        //원시타입의 경우 arr2는 안바뀌지만 객체형의 경우 arr2도 같이 바뀜
        //

        // <forEach 함수, callback fn>--------------------------------------
        // const arr = ['참외', '키위', '감귤'];
        // arr.forEach(function(item, index) {
        //     console.log(item, `은(는)${index}번째 입니다.` );
        // });

        // const arr = ['참외', '키위', '감귤'];
        // function callbackfn(item, index, arr) {
        //     console.log(item, `은(는)${index}번째 입니다.` );
        //     console.log("원본 배열은",arr,"입니다.");
        // };
        // arr.forEach(callbackfn);
        // 위나 아래나 과정, 결과는 같다

        // <map>--------------------------------------------------------
        // map -> callbackfn 에서 return된 값들을 모아 새 배열로 만들어줌
        // const arr = [1, 2, 3];
        // function callbackfn(item) {
        //     return item * 2;
        // }
        // console.log(arr.map(callbackfn));
        // console.log(arr)//원본 값은 변하지 않음!

        // const arr = [1, 2, 3];
        // const newArr = arr.map(function (item, index) {
        //     return item * index;
        // });

        // console.log(newArr);

        //<filter>-----------------------------------------
        // true false 값을 filterFn으로, true일경우 배열에 넣고 false일 경우 넣지 않는다. 한바퀴 돌면 배열 반환
        // const arr = [1,2,3,4,5];
        // function filterFn(num) {
        //     return num%2===1;
        // }
        // const result = arr.filter(filterFn)
        // console.log(result);

        //filterFn 화살표함수-----------------------------------------
        // const filterFn = (num)=>num%2===1;
        // const result = arr.filter(filterFn);
        // console.log(result);
        //위처럼 하면 filterFn이 남으니까 아래처럼,
        // const result = arr.filter((num)=>num%2===1);
        //가독성 챙기면 밑
        // const result = arr.filter(function filterFn(num) {
        //     return num%2===1 // 홀수인지 판별해주는 조건식
        // })

        //reduce 함수 (arr.reduce) ---------------------------------------------
        // const arr = [1, 2, 3, 4]
        // //1부터 4까지 다 더하는 함수
        // // 1+2->3, 3+3->6, 6+4->10
        // function reducer(x, y) {
        //     console.log(x, y);
        //     return x+y
        // }
        // const result = arr.reduce(reducer, 0);
        // //서순을 따지자면, 0을 x에 넣고 arr[0]을 y에 넣음 ->return을 0이었던 초기값 자리로.
        // // 그 다음은 1이 된 초기값을 x에, arr[1]을 y에....마지막까지 반복.
        // console.log(result);
        
        // 초기값 없을 때 에러나는 경우 찾기 << 선택과제
        // <reduce를 이용해서 홀수만 누적하기>--------------------------------------
        // const arr = [1, 2, 3, 4, 5];
        // function reducer(x, y) {
        //     if (y%2 === 1) {
        //         console.log(x, y);
        //         return x+y;
        //     }
        //     else return x;
        // };
        // const result = arr.reduce(reducer, 0);
        // console.log(result);

        const arr1 = [1, 2, 3, 4, 5];
        const arr2 = [];

        function reducer(x, y) {
            if (y%2 === 1) {
                return x+y;
            }
            else return x;
        };
        //배열 요소 O, 초기값 O : 결과 9
        //const result = arr1.reduce(reducer, 0);
        //배열 요소 O, 초기값 X : 결과 9
        //const result = arr1.reduce(reducer);
        // //배열 요소 X, 초기값 O : 결과 0
        //const result = arr2.reduce(reducer, 0);
        // //배열 요소 X, 초기값 X : 결과 에러
        // const result = arr2.reduce(reducer);

        console.log(result);

        //test






    </script>

</body>

</html>